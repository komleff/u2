# M2.1: Protobuf Network Protocol

**Status**: ✅ Implementation Complete  
**Tests**: 190/190 passing (100%)  
**Date**: 2025-11-18  
**Spec Compliance**: ✅ Aligned with spec_u2_architecture_v086_minimal.md

## Overview

M2.1 implements the Protobuf-based network protocol for client-server communication in the U2 game engine. This establishes the foundation for the M2 milestone (Network and Authoritative Server).

## Protocol Design

### Architecture

The protocol follows an **authoritative server** model:
- **Server** is the source of truth for all game state
- **Clients** send input commands to the server
- **Server** broadcasts world state snapshots to all clients
- No client-side prediction or reconciliation yet (planned for M2.2)

### Message Flow

```
Client                          Server
  |                               |
  |-- ConnectionRequestProto ---->|
  |<-- ConnectionAcceptedProto ---|
  |                               |
  |-- PlayerInputProto ---------->|  (repeated, every frame)
  |<-- WorldSnapshotProto --------|  (broadcast, 20-60 Hz)
  |                               |
  |<-- DisconnectProto -----------|  (on error or shutdown)
```

## Protocol Buffers Definition

### Location
- **File**: `src/shared/Proto/ecs.proto`
- **Namespace**: `U2.Shared.Proto`
- **Generated Code**: Auto-generated via `Grpc.Tools` during build

### Core Messages

#### 1. Client → Server Messages

##### PlayerInputProto
Player control input sent every frame.

```protobuf
message PlayerInputProto {
  uint32 client_id = 1;         // Client identifier
  uint32 sequence_number = 2;   // Input sequence for acknowledgment
  uint64 timestamp_ms = 3;      // Client timestamp
  ControlStateProto control_state = 4;
  bool flight_assist = 5;       // FA:ON (true) or FA:OFF (false)
}
```

**Fields:**
- `client_id`: Assigned by server in ConnectionAccepted
- `sequence_number`: Monotonically increasing, used for input acknowledgment and lag compensation
- `timestamp_ms`: Client-side timestamp for latency calculation
- `control_state`: Thrust, strafe, and yaw inputs
- `flight_assist`: Flight assist mode (true = FA:ON, false = FA:OFF) - **M2.1 spec compliance**

##### ConnectionRequestProto
Initial connection request from client.

```protobuf
message ConnectionRequestProto {
  string player_name = 1;
  string version = 2;           // Client version for compatibility check
}
```

**Fields:**
- `player_name`: Display name for the player
- `version`: Protocol version (e.g., "0.8.6") for compatibility validation

#### 2. Server → Client Messages

##### ConnectionAcceptedProto
Server response confirming connection.

```protobuf
message ConnectionAcceptedProto {
  uint32 client_id = 1;         // Assigned client ID
  uint32 entity_id = 2;         // Assigned player entity ID
  uint64 server_time_ms = 3;    // Server time for synchronization
}
```

**Fields:**
- `client_id`: Unique identifier for this client connection
- `entity_id`: The ECS entity ID for the player's ship
- `server_time_ms`: Server timestamp for clock synchronization

##### WorldSnapshotProto
Complete world state broadcast.

```protobuf
message WorldSnapshotProto {
  uint32 tick = 1;              // Server tick number
  uint64 timestamp_ms = 2;      // Server timestamp
  repeated EntitySnapshotProto entities = 3;
}
```

**Fields:**
- `tick`: Monotonically increasing server tick counter
- `timestamp_ms`: Server time when snapshot was created
- `entities`: Array of all visible entities

##### EntitySnapshotProto
State of a single entity.

```protobuf
message EntitySnapshotProto {
  uint32 entity_id = 1;
  Transform2DProto transform = 2;
  VelocityProto velocity = 3;
  ControlStateProto control_state = 4;
  FlightAssistProto flight_assist = 5;
  HealthProto health = 6;
}
```

**Fields:**
- `entity_id`: ECS entity identifier
- `transform`: Position (x, y) and rotation
- `velocity`: Linear (x, y) and angular velocity
- `control_state`: Current control inputs (for other players)
- `flight_assist`: Flight assist enabled state (M3)
- `health`: Current HP and max HP

##### DisconnectProto
Disconnect notification.

```protobuf
message DisconnectProto {
  uint32 client_id = 1;
  string reason = 2;
}
```

**Fields:**
- `client_id`: ID of disconnecting client
- `reason`: Human-readable disconnect reason

#### 3. Message Wrappers

##### ClientMessageProto
Top-level wrapper for all client messages.

```protobuf
message ClientMessageProto {
  oneof message {
    ConnectionRequestProto connection_request = 1;
    PlayerInputProto player_input = 2;
  }
}
```

**Usage**: Allows single message type for client→server communication with type discrimination via `oneof`.

##### ServerMessageProto
Top-level wrapper for all server messages.

```protobuf
message ServerMessageProto {
  oneof message {
    ConnectionAcceptedProto connection_accepted = 1;
    WorldSnapshotProto world_snapshot = 2;
    DisconnectProto disconnect = 3;
  }
}
```

**Usage**: Allows single message type for server→client communication with type discrimination via `oneof`.

## Code Generation

### Build Integration

The project uses `Grpc.Tools` NuGet package to automatically generate C# code from `.proto` files during build.

**Configuration** (`U2.Shared.csproj`):
```xml
<ItemGroup>
  <PackageReference Include="Grpc.Tools" Version="2.76.0">
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    <PrivateAssets>all</PrivateAssets>
  </PackageReference>
</ItemGroup>

<ItemGroup>
  <Protobuf Include="Proto\ecs.proto" GrpcServices="None" />
</ItemGroup>
```

**Generated Code Location**: `src/shared/obj/Debug/net8.0/Proto/Ecs.cs`

### Usage Example

#### Client: Send Player Input

```csharp
using U2.Shared.Proto;
using Google.Protobuf;

var input = new PlayerInputProto
{
    ClientId = myClientId,
    SequenceNumber = inputSequence++,
    TimestampMs = (ulong)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
    ControlState = new ControlStateProto
    {
        Thrust = 1.0f,
        StrafeX = 0.0f,
        StrafeY = 0.0f,
        YawInput = 0.5f
    }
};

byte[] messageBytes = input.ToByteArray();
// Send messageBytes over network...
```

#### Server: Create World Snapshot

```csharp
var snapshot = new WorldSnapshotProto
{
    Tick = serverTick,
    TimestampMs = (ulong)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
};

foreach (var entity in gameContext.GetEntities())
{
    snapshot.Entities.Add(EntitySerializer.ToSnapshot(entity));
}

byte[] messageBytes = snapshot.ToByteArray();
// Broadcast messageBytes to all clients...
```

#### Deserialize Message

```csharp
// Receive messageBytes from network...
var message = PlayerInputProto.Parser.ParseFrom(messageBytes);
Console.WriteLine($"Client {message.ClientId} thrust: {message.ControlState.Thrust}");
```

## Testing

### Test Coverage

**File**: `src/shared/Tests/Proto/NetworkMessagesTests.cs`

**Tests** (10 total):
1. `PlayerInputProto_CanSerializeAndDeserialize` - Input message roundtrip
2. `ConnectionAcceptedProto_CanSerializeAndDeserialize` - Connection response
3. `ConnectionRequestProto_CanSerializeAndDeserialize` - Connection request
4. `DisconnectProto_CanSerializeAndDeserialize` - Disconnect message
5. `ClientMessageProto_ConnectionRequest_CanSerializeAndDeserialize` - Wrapper with connection request
6. `ClientMessageProto_PlayerInput_CanSerializeAndDeserialize` - Wrapper with player input
7. `ServerMessageProto_ConnectionAccepted_CanSerializeAndDeserialize` - Wrapper with connection accepted
8. `ServerMessageProto_WorldSnapshot_CanSerializeAndDeserialize` - Wrapper with world snapshot
9. `ServerMessageProto_Disconnect_CanSerializeAndDeserialize` - Wrapper with disconnect
10. `WorldSnapshotProto_WithMultipleEntities_CanSerializeAndDeserialize` - Large snapshot with 5 entities

### Running Tests

```bash
dotnet test src/shared/U2.Shared.csproj
```

**Result**: 183/183 tests passing (100%)

## Wire Format

### Encoding
- **Binary**: Protocol Buffers binary format
- **Efficiency**: Compact, typically 30-50% smaller than JSON
- **Backwards Compatibility**: Fields can be added without breaking older clients (via field numbers)

### Message Size Estimates

| Message Type | Typical Size | Notes |
|--------------|--------------|-------|
| PlayerInputProto | ~40 bytes | Per-frame overhead |
| ConnectionRequestProto | ~30 bytes | One-time |
| ConnectionAcceptedProto | ~25 bytes | One-time |
| EntitySnapshotProto | ~70-100 bytes | Depends on components |
| WorldSnapshotProto (10 entities) | ~800-1000 bytes | Broadcast rate dependent |
| DisconnectProto | ~20-50 bytes | One-time |

## Next Steps (M2.2)

The M2.1 protocol provides the foundation for:

1. **M2.2: Transport Layer**
   - UDP or WebSocket implementation
   - Connection management
   - Message framing and reliability

2. **M2.3: Client-Side Prediction**
   - Local simulation of player's own ship
   - Server reconciliation on mismatch
   - Smooth correction via interpolation

3. **M2.4: State Synchronization**
   - Delta compression for world snapshots
   - Interest management (only send nearby entities)
   - Bandwidth optimization

4. **M2.5: Input Acknowledgment**
   - Server acknowledges received inputs
   - Client discards acknowledged inputs
   - Lag compensation for fair combat

## References

- **Specification**: `docs/specs/gameplay/spec_u2_dev_plan_v086_extended.md` (lines 114-142)
- **Proto Definition**: `src/shared/Proto/ecs.proto`
- **Tests**: `src/shared/Tests/Proto/NetworkMessagesTests.cs`
- **Entity Serializer**: `src/shared/ECS/Serialization/EntitySerializer.cs`
- **Google Protocol Buffers**: https://protobuf.dev/
- **Grpc.Tools**: https://www.nuget.org/packages/Grpc.Tools/

## DoD Verification

| Criterion | Status | Notes |
|-----------|--------|-------|
| Protobuf messages defined | ✅ | All M2 message types implemented |
| Client input messages | ✅ | PlayerInputProto with sequence numbers |
| Server state messages | ✅ | WorldSnapshotProto with tick/timestamp |
| Connection management | ✅ | Request, Accept, Disconnect messages |
| Message wrappers | ✅ | ClientMessageProto, ServerMessageProto |
| Auto-generation from .proto | ✅ | Grpc.Tools integration |
| Serialization tests | ✅ | 10 tests covering all message types |
| All tests passing | ✅ | 183/183 (100%) |
| Documentation | ✅ | This README |
