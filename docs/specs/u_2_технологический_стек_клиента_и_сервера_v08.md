Короткий ответ

Трёхмерный графический движок желателен. Даже если физика полёта рассчитывается в плоскости, а камера показывает «вид сверху» или «изометрию», трёхмерный рендер решает задачи:

- отображение дальности обзора 10–20 км (отсечение невидимых объектов, проверка глубины, вывод множества повторяющихся объектов силами видеокарты);
- резерв на будущее: трёхмерные столкновения, эффекты, изменение камеры.

При этом физическая модель остаётся двумерной, что упрощает расчёты.

---

## 1. Базовый стек (по умолчанию)

Цель этого раздела — описать рекомендуемый набор технологий для клиента и сервера: на чём строим прототип, какие задачи это решает и какие ограничения накладывает.

### 1.1. Клиент

**Игровой движок.**  
Рекомендуется использовать Unity (долгосрочная поддерживаемая версия, LTS) с универсальным графическим конвейером URP в трёхмерном режиме. Отдельный специализированный «двумерный» конвейер не нужен: двумерная картинка достигается настройкой камеры и сцены.

Преимущества:

- готовая экосистема под 3D-графику и эффект «далёкого космоса»;
- единый проект для ПК, Web и мобильных устройств;
- возможность постепенно добавлять более сложные эффекты без смены движка.

Ограничения:

- необходимо придерживаться рекомендуемых настроек производительности (уровни качества, освещение, тени), иначе легко получить лишнюю нагрузку;
- команду придётся дисциплинировать по части «чистоты» сцен и ассетов (размеры текстур, количество материалов и т. п.).

**Язык программирования.**  
Основной язык на клиенте — C#. Это стандартный выбор для Unity, он хорошо интегрирован со всеми инструментами движка.

**Графика и камеры.**

Предлагается двухкамерная схема:

- ближняя камера — перспективная, с дальностью зрения порядка 1,5–2 км; рисует «физический» мир: корабль игрока, близкие астероиды, обломки, эффекты;
- дальняя камера — отдельный слой отрисовки, который показывает упрощённые обозначения объектов (иконки, маркеры, силуэты) на дистанции до 10–20 км, без участия в расчётах глубины.

Псевдо-изометрический вид достигается:

- либо перспективной камерой с небольшим углом обзора и наклоном;
- либо ортографической камерой, если нужен «чистый» вид сверху (например, для отладочных режимов или интерфейсных наложений).

Такой подход даёт:

- читаемое изображение вблизи (игрок видит детали);
- при этом система способна показывать удалённые объекты без перегрузки видеокарты и ошибок глубины.

**Пакеты и подсистемы Unity (минимальный набор).**

Рекомендуется включить:

- систему ввода (Input System) — единый слой обработки клавиатуры, мыши, геймпадов и сенсорных экранов;
- TextMeshPro — для чётких подписей и интерфейса;
- систему адресуемых ресурсов (Addressables) — для гибкой загрузки и обновления ассетов;
- коллекции и вычислительные библиотеки (Unity Collections, Burst) — при необходимости ускорения математических расчётов на клиенте;
- при необходимости — Cinemachine для удобной настройки камеры сопровождения (можно добавить после первых этапов, когда базовый вид уже определён).

Кроме того, на клиенте понадобится собственная отладочная панель (Debug HUD) и использование штатного профайлера Unity для анализа производительности.

### 1.2. Сервер

**Платформа и язык.**  
Рекомендуется сервер на платформе .NET 8 (язык C#) в виде приложения без графического интерфейса. Это даёт:

- высокую скорость разработки — тот же язык и часть общих библиотек с клиентом;
- хороший набор инструментов профилирования и тестирования;
- возможность развернуть сервер на разных операционных системах.

**Сеть.**

Для обмена данными используются два канала:

- для ПК и мобильных клиентов — протокол поверх UDP (например, библиотека LiteNetLib или ENet для C#), который позволяет эффективно передавать частые небольшие сообщения с контролируемой надёжностью;
- для браузерной версии — WebSocket, реализованный в составе веб-сервера (Kestrel) с поддержкой двустороннего обмена.

Такой выбор даёт:

- достаточно быстрый и гибкий обмен с «толстыми» клиентами (ПК, мобильные устройства);
- стандартный доступ из браузера без установки дополнительных драйверов или плагинов.

**Сериализация и конфигурация.**

Для сериализации сетевых сообщений:

- рекомендуется использовать двоичный формат Protobuf (например, библиотека protobuf-net или официальный клиент Google.Protobuf) — он компактен и хорошо подходит для частых сообщений;
- для конфигурационных файлов на ранних этапах (M0–M1) можно использовать JSON, так как он проще в редактировании и чтении.

**Тестирование и наблюдение.**

На сервере нужны:

- модульные и интеграционные тесты (NUnit или xUnit), а также тесты свойств (FsCheck), чтобы проверять общие свойства алгоритмов (например, сохранение инвариантов);
- измерения производительности (BenchmarkDotNet);
- логирование (например, через Serilog) и экспорт метрик в системы наблюдения (Prometheus, OpenTelemetry).

Это позволяет:

- рано обнаруживать ошибки и падения производительности;
- видеть реальные задержки, нагрузку на процессор и память на боевых стендах.

### 1.3. Общие библиотеки

Часть кода разделяется между клиентом и сервером:

- математические функции (векторы, матрицы, операции над ними) — на стороне .NET можно использовать System.Numerics, а на клиенте, при необходимости, дополнить Unity-специфическими типами;
- общие структуры данных для игровых сущностей (состояние корабля, параметры мира, сетевые сообщения).

Для логической структуры объектов удобно использовать некоторую форму компонентной архитектуры (ECS — «сущность–компонент–система»):

- каждая сущность (корабль, снаряд, обломок) — это набор компонент (положение, скорость, состояние щита и т. д.);
- отдельные системы обрабатывают соответствующие компоненты (система физики, система управления, система урона).

Важно, чтобы модели данных, связанные с протоколом, были одинаковыми и на клиенте, и на сервере. Это уменьшает количество ошибок при обмене данными.

---

## 2. Возможные альтернативы

Если по какой-то причине Unity использовать нельзя:

- Godot 4 (сценарный язык GDScript или C#) подходит для двумерных и изометрических игр. Однако:
  - потребуется самостоятельно собирать сетевой слой и больше внимания уделять производительности Web-версии и мобильных клиентов;
  - часть готовой инфраструктуры, доступной в Unity, придётся реализовывать с нуля.
- Собственный движок на C++ с использованием низкоуровневых библиотек (например, SDL), даёт максимальный контроль и потенциально высокую производительность, но:
  - резко увеличивает стоимость разработки;
  - требует значительно более опытной команды по низкоуровневому программированию;
  - замедляет создание прототипа.

Поэтому для прототипа и ранних версий проекта такая альтернатива рассматривается только при наличии жёстких внешних ограничений (например, строгие требования к лицензии или полный отказ от использования проприетарных движков).

---

## 3. Зачем трёхмерный рендер при физике в плоскости

Даже если физика полёта рассчитывается в двумерной плоскости, задачи визуализации остаются трёхмерными:

1. Большая дальность обзора.  
   Необходимо видеть другие корабли и объекты на расстоянии в десятки километров. Трёхмерный графический конвейер позволяет:
   - автоматически отбрасывать объекты, которые не попадают в «пирамиду видимости» камеры;
   - использовать буфер глубины, чтобы скрывать дальние объекты за ближними без лишних вычислений;
   - выводить большое число одинаковых объектов (например, астероиды, обломки) за небольшой счёт вызовов к видеокарте.

2. Готовность к развитию.  
   В будущем может понадобиться:
   - переход к полноценным трёхмерным столкновениям;
   - сложные световые и визуальные эффекты;
   - разные типы камер (например, переход к виду из кабины или свободной камере).

   Если с самого начала использовать трёхмерный движок, все эти шаги не потребуют смены технологической базы.

3. Читаемость сцены.  
   Перспективная камера и глубина создают ощущение масштаба: ясно, что далеко, а что близко, корабли не «налипают» друг на друга, даже если всё ещё рассчитывается в одной плоскости.

---

## 4. Реализация «2D-изометрии с перспективой»

Этот раздел описывает, как именно организовать камеру и сцены, чтобы сохранить простую физику в плоскости, но получить понятную трёхмерную картинку.

### 4.1. Камеры и слои

Используются три логических слоя:

1. Ближний мир.  
   Камера с перспективной проекцией и относительно небольшим углом обзора отображает:

   - корабль игрока;
   - ближайшие корабли и объекты;
   - следы, выхлоп, взрывы и другие эффекты.

   Дальность этой камеры ограничивается примерно 1,5–2 километрами. Это даёт приемлемую точность буфера глубины и предотвращает «дрожание» глубины на средних расстояниях.

2. Дальний информационный слой.  
   Вторая камера (или отдельный проход рисования) показывает:

   - условные обозначения удалённых кораблей и объектов (иконки, рамки, символы);
   - линии маршрута или связи;
   - подсказки вроде «направления на цель».

   Эти элементы изображаются в отдельном слое, без учёта глубины, и могут легко масштабироваться и изменяться по цвету в зависимости от расстояния и других параметров.

3. Интерфейс (HUD).  
   Поверх всего рисуется слой интерфейса:

   - приборы корабля;
   - индикаторы состояния;
   - информация о выбранной цели;
   - сообщения об опасности.

Такое разделение позволяет независимо настраивать качество и частоту обновления: например, интерфейс всегда должен быть чётким, а дальние обозначения можно обновлять реже.

### 4.2. Координаты и точность

При дальности порядка десятков километров возникает проблема точности чисел:

- на сервере можно использовать числа повышенной точности (тип double) и хранить «мировые» координаты без упрощений;
- на клиенте удобнее работать с числами одинарной точности (float), так как они более эффективно обрабатываются на видеокарте.

Чтобы сохранить точность на клиенте, используется приём «плавающего начала координат»:

- периодически (например, когда корабль игрока удаляется от исходной точки дальше чем на 1–2 километра) система смещает всю сцену так, чтобы корабль игрока снова оказался близко к началу координат;
- сервер при этом продолжает работать в своих глобальных координатах, а клиент переводит полученные координаты в локальную систему.

Для выбора, какие объекты вообще нужно отображать и обрабатывать, используется пространственный поиск (например, разбиение мира на квадратные блоки и хранение в каждом списков объектов). Это позволяет быстро находить только те объекты, которые находятся вблизи игрока и нужны для расчётов и отображения.

### 4.3. Уровни детализации

Тот же объект можно показывать по-разному в зависимости от расстояния:

- вблизи — как полноценную модель или детальный спрайт;
- дальше — как упрощённый силуэт или иконку;
- совсем далеко — вообще только значок на информационном слое.

Это экономит ресурсы видеокарты и делает картинку менее перегруженной, особенно в местах с большим количеством объектов.

---

## 5. Сеть и большая дальность обзора

Сетевая модель должна учитывать, что игрок может видеть объекты на разных расстояниях:

- обнаружение объектов: сервер решает, какие объекты входят в область «видимости» наблюдателя, и отправляет клиенту данные о них с учётом задержки распространения сигнала (замедленный свет);
- частота обновления: объекты, которые находятся далеко и мало влияют на текущий бой, можно обновлять реже; ближайшие корабли и снаряды требуют более частых обновлений;
- отображение: удалённые объекты чаще всего показываются в виде иконок и краткой информации, поэтому небольшие погрешности в их точных координатах не критичны.

Клиент получает от сервера сообщения о «наблюдениях» (Observation), каждое из которых снабжено временем, когда событие произошло, и учётом задержки света. Клиент складывает их в очередь будущих состояний и показывает в нужный момент. Это помогает скрыть сетевые задержки за игровым объяснением («свет идёт медленно»).

---

## 6. Рекомендуемые пакеты и библиотеки

В этом разделе идея не в том, чтобы перечислить все возможные инструменты, а в том, чтобы зафиксировать минимально достаточный набор.

### 6.1. Клиент (Unity)

- система ввода (Input System) — единый способ обработки всех устройств управления;
- универсальный графический конвейер (URP) — основа рендера;
- Addressables — для управления ресурсами и сценами;
- Burst и коллекции — для ускорения вычислений (например, при расчёте траекторий и вспомогательных таблиц) без переписывания на низкоуровневых языках;
- при необходимости — Cinemachine для гибкой настройки камеры.

Более тяжёлые технологии (например, ECS-решения нового поколения) целесообразно добавлять только когда число одновременно существующих объектов станет очень большим.

### 6.2. Сервер (.NET)

- библиотека для работы по протоколу UDP (LiteNetLib или аналог) — для основного игрового трафика;
- реализация WebSocket (через Kestrel) — для браузерных клиентов;
- Protobuf (protobuf-net или Google.Protobuf) — для компактных и строгих по типам сообщений;
- Serilog или аналогичная система логирования — для записи ключевых событий и ошибок;
- Prometheus-совместимый экспорт метрик и/или OpenTelemetry — для интеграции со средствами наблюдения;
- NUnit или xUnit — для модульных тестов;
- FsCheck — для тестов свойств (например, сохранения инвариантов);
- BenchmarkDotNet — для измерения производительности критических участков (физика, проверка столкновений и т. д.).

### 6.3. Общие вспомогательные инструменты

- схемы для описания конфигураций (например, на основе YAML или JSON) с автоматической проверкой корректности и возможностью генерации типов;
- вспомогательные инструменты платформы .NET (форматирование кода, подсчёт покрытия тестами, работа с версиями).

---

## 7. Настройки под дальность 10–20 км

При проектировании следует заранее заложить:

- ближнюю камеру с дальностью порядка 2 км для основного игрового действия;
- дальний информационный слой для отображения объектов до 10–20 км в виде упрощённых значков;
- механизмы выбора цели и взаимодействия с ней, которые не требуют от игрока точного попадания курсором по маленькому объекту на огромной дистанции (например, по списку целей или по крупным иконкам).

Такая конфигурация:

- сохраняет стабильность буфера глубины (нет конфликтов между очень близкими и очень дальними объектами);
- упрощает работу сетевого кода (не нужно часто обновлять точные координаты всех дальних объектов);
- делает интерфейс управляемым и понятным.

---

## 8. Когда достаточно «чистого» двумерного подхода

Если целевой дизайн игры изменится и:

- дальность обзора будет ограничена несколькими километрами;
- не потребуется работать с эффектом замедленного света на десятки километров;
- не планируется переход к трёхмерным столкновениям и камерам в перспективе,

тогда можно рассмотреть полностью двумерный графический конвейер в Unity (ортографическая камера, двухмерные сцены). Это упростит часть настройки графики, но в текущих требованиях (видимость целей на 10–20 км с эффектом расстояния и задержки света) трёхмерный конвейер выглядит более надёжным и гибким решением.

---

## 9. Итоговые рекомендации

1. Использовать трёхмерный движок (Unity с URP) и при этом оставить физику полёта в двумерной плоскости.  
2. Реализовать двухкамерную схему: ближний мир до примерно 2 км и дальний информационный слой до 10–20 км.  
3. Сервер построить на .NET 8, с основным транспортом поверх UDP и дополнительным WebSocket для браузера; использовать компактный двоичный формат сообщений.  
4. На ранних этапах ограничиться минимально необходимым набором библиотек и не вводить сложные системы, пока не появится реальная необходимость.  
5. С самого начала заложить «плавающее начало координат» и пространственное разбиение мира, чтобы избежать проблем точности и производительности при работе с большими расстояниями.

Отдельные режимы управления кораблём, такие как более сложный «сопряжённый» режим (Coupled), рассматриваются как функция более поздних этапов разработки и не влияют на выбор основного технологического стека.

---

## 10. Глоссарий

**Addressables** — система Unity для загрузки ресурсов по адресам, которая позволяет обновлять и подменять содержимое без полной пересборки клиента.

**Burst** — технология компиляции в Unity, позволяющая ускорять вычислительно тяжёлый код за счёт генерации более эффективного машинного кода.

**Depth-буфер (буфер глубины)** — область памяти видеокарты, в которой хранится глубина каждого пикселя; используется для того, чтобы правильно определять, какой объект перекрывает другой.

**Input System** — система обработки ввода в Unity, позволяющая использовать один общий слой для клавиатуры, мыши, геймпадов и сенсорного ввода.

**Kestrel** — встроенный веб-сервер в платформе .NET, который используется для обработки HTTP-запросов и WebSocket-соединений.

**Protobuf (Protocol Buffers)** — формат сериализации данных, разработанный компанией Google: компактный, двоичный, с жёстко описанными структурами сообщений.

**UDP (User Datagram Protocol)** — сетевой протокол передачи датаграмм без установления соединения; даёт малые задержки и низкий накладной расход, но не гарантирует доставку каждого пакета.

**WebSocket** — протокол поверх HTTP, позволяющий устанавливать постоянное двустороннее соединение между клиентом (обычно браузером) и сервером.

**Floating origin (плавающее начало координат)** — метод периодического переноса всей сцены так, чтобы точка отсчёта координат оставалась близко к игроку, что уменьшает численные ошибки при работе с большими расстояниями.

**Квадродерево** — структура данных, которая разбивает плоскость на квадраты и позволяет эффективно находить объекты в заданной области.

**Уровень детализации** — вариант модели или изображения объекта с разной степенью подробности. На близком расстоянии используется детальный вариант, на далёком — упрощённый.

**URP (Universal Render Pipeline)** — универсальный графический конвейер Unity, поддерживающий разные платформы и позволяющий гибко настраивать качество и производительность.

**LiteNetLib / ENet для C#** — библиотеки для работы с сетевыми соединениями поверх протокола UDP в приложениях на .NET.

**Serilog** — библиотека для структурированного логирования в .NET-приложениях.

**Prometheus / OpenTelemetry** — системы и стандарты для сбора метрик и трассировки работы приложений; используются для мониторинга и диагностики.

**BenchmarkDotNet** — библиотека для проведения микро-бенчмарков в .NET, которая помогает измерять и сравнивать производительность отдельных участков кода.

**FsCheck** — библиотека для тестирования свойств в .NET: вместо ручного набора тестовых примеров случайным образом генерирует входные данные и ищет нарушения заявленных свойств.

**Cinemachine** — модуль Unity для удобной настройки и управления виртуальными камерами (следование за объектом, плавные переходы и т. п.).

**HUD (Head-Up Display, прицельная панель)** — область интерфейса, где постоянно отображается ключевая информация для игрока: скорость, состояние корабля, выбранная цель и др.

**Coupled-режим** — рабочее название режима управления, при котором система помогает пилоту удерживать корабль на курсе, сглаживает манёвры и управляет скольжением. В текущем документе рассматривается как функция более поздних версий и не влияет на выбор технологий.

