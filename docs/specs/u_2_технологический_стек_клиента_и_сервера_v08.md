# U2 — Технологический стек клиента и сервера

Версия: 0.8.6 (минимальная, для ИИ-агентов)

Документ описывает утверждённый набор технологий, достаточный для реализации Архитектуры v0.8.6 (минимальная), плана разработки v0.8.6 и ТЗ «Создание симулятора в Unity».

Цель: дать ИИ-агентам чёткий список библиотек и инструментов с минимальным количеством самописного кода.

------

## 1. Принципы выбора

1. Использовать стандартные подсистемы Unity и типовые библиотеки .NET, а не писать обвязку с нуля.
2. Один основной язык — C# — для клиента, сервера и общей библиотеки.
3. Общий код для физики, протокола и конфигов в отдельной «shared»‑библиотеке.
4. Всё, что не требуется Архитектурой 0.8.6 и Планом 0.8.6, в стек не включать.

------

## 2. Сводная таблица технологий

| Область             | Назначение                      | Технология / библиотека                     | Статус                       |
| ------------------- | ------------------------------- | ------------------------------------------- | ---------------------------- |
| Клиентский движок   | Рендер, ввод, сцены             | Unity LTS (3D, URP)                         | Обязательно                  |
| Язык на клиенте     | Игровая логика                  | C#                                          | Обязательно                  |
| Ввод                | Клавиатура, мышь, геймпад       | Unity Input System                          | Обязательно                  |
| UI                  | HUD, иконки, текст              | Unity UI (Canvas + TextMeshPro)             | Обязательно                  |
| ECS                 | Сущности/компоненты/системы     | Entitas (или аналогичный зрелый ECS для C#) | Обязательно для общей логики |
| Серверная платформа | Авторитарный сервер             | .NET 8 (консольное приложение)              | Обязательно                  |
| Сетевой транспорт   | Надёжный обмен по «UDP‑модели»  | LiteNetLib                                  | Обязательно для ПК/мобайл    |
| Web‑клиенты         | Транспорт для WebGL             | ASP.NET Core + WebSocket                    | Обязательно для WebGL        |
| Сериализация        | Сообщения клиент↔сервер         | Google.Protobuf или protobuf‑net            | Обязательно                  |
| Конфиги             | ТТХ кораблей, настройки локаций | JSON + System.Text.Json                     | Обязательно                  |
| Логирование         | Технические логи сервера        | Serilog                                     | Рекомендуется                |
| Метрики             | Время тика, задержки, нагрузки  | prometheus-net                              | Рекомендуется                |
| Тесты               | Модульные/интеграционные тесты  | xUnit или NUnit                             | Обязательно                  |
| Профилирование      | Замеры производительности       | BenchmarkDotNet                             | Рекомендуется                |

Допускается замена Entitas на другой устоявшийся ECS для C# (например, Leopotam.EcsLite), если архитектурно он покрывает те же задачи.

------

## 3. Клиент (Unity)

### 3.1. Движок и графика

**Использовать:**

- Unity LTS (одна конкретная LTS‑версия, зафиксировать в репозитории).
- Универсальный рендер‑конвейер (URP) в трёхмерном режиме.

**Причины:**

- Нужен 3D‑рендер для «вида сверху с перспективой» и дальности обзора до 10–20 км.
- URP даёт единый конвейер для ПК и WebGL.

### 3.2. Ввод и интерфейс

**Использовать:**

- `com.unity.inputsystem` для работы с клавиатурой, мышью и геймпадом.
- Стандартный Canvas + TextMeshPro для HUD и отладочных панелей.

**Причины:**

- Позволяет без самописной обвязки поддерживать несколько устройств ввода.
- HUD и отладка реализуются на типовом UI Unity.

### 3.3. Физика и ECS на клиенте

**Физика:**

- Для минимальной версии движение в плоскости рассчитывается в общем C#‑коде (shared‑библиотека), а не через встроенную физику Unity.
- Unity Physics/2D используются только для простых визуальных эффектов (по необходимости), не как основной источник истины.

**ECS:**

- Entitas (или другой зрелый ECS для C#) используется для структурирования клиентской логики: состояние корабля, локальное предсказание, отображение, HUD.

**Причины:**

- Общая физика должна совпадать с серверной, поэтому расчёты выносятся в общий код.
- ECS снижает объём самописной архитектуры: логика строится на готовом паттерне сущность/компонент/система.

------

## 4. Сервер (.NET 8)

### 4.1. Платформа

**Использовать:**

- .NET 8 (консольное приложение без графики).
- C# как основной язык.

**Причины:**

- Совместный стек с Unity‑клиентом (C# и общие библиотеки).
- Современная производительность и поддержка асинхронных операций.

### 4.2. Сетевой транспорт

**ПК/мобайл:**

- LiteNetLib как транспорт поверх протокола датаграмм.
- Режим с надёжными и ненадёжными каналами (для разных типов сообщений).

**WebGL:**

- ASP.NET Core Kestrel + встроенная поддержка WebSocket.

**Причины:**

- LiteNetLib закрывает основную часть задач по работе с ненадёжным транспортом (повторы, очереди) без самописного транспорта.
- WebSocket в ASP.NET Core стандартен и хорошо поддерживается.

### 4.3. Сериализация и конфигурации

**Сообщения:**

- Google.Protobuf или protobuf‑net.
- Все игровые пакеты (управление, снимки состояния, события) описываются схемами и генерируются.

**Конфиги:**

- JSON‑файлы с использованием System.Text.Json.
- ТТХ кораблей и параметры локаций — строго описанные структуры, согласованные с документом по ТТХ.

**Причины:**

- Генерация типов по схемам уменьшает объём самописного кода по сериализации.
- System.Text.Json — стандартная библиотека, без внешних зависимостей.

### 4.4. Тесты, логи, метрики

**Тесты:**

- xUnit или NUnit для модульных и интеграционных тестов.

**Логирование:**

- Serilog для структурированных логов (в консоль и, при необходимости, в файл или систему сбора логов).

**Метрики:**

- prometheus-net для экспорта базовых показателей (время тика, число сущностей, задержки).

**Причины:**

- Все перечисленные библиотеки широко применяются и активно поддерживаются, что снижает риски при использовании ИИ‑агентов.

------

## 5. Общая библиотека (Shared)

**Назначение:** код, общий для клиента и сервера.

**Содержимое:**

- Структуры данных для состояния корабля, локации и простого урона.
- Реализация минимальной физики в плоскости (без тепла, щитов и брони).
- Реализация протокола сообщений (типы Protobuf и обёртки).
- Набор систем ECS, общих для клиента и сервера (по мере необходимости).

**Технологии:**

- C# классическая библиотека.
- Те же библиотеки, что и на сервере: System.Numerics для векторов, Protobuf-типы для сообщений.

**Причины:**

- Исключение дублирования логики.
- Упрощение работы ИИ‑агентов: вся «истина» по формату данных в одном месте.

------

## 6. Что не входит в стек v0.8.6

Сознательно **не включаются** в минимальный стек (но могут появиться в будущих версиях):

- Любые специализированные библиотеки для сложной 3D‑физики, тепла, щитов, брони.
- Сложные сетевые фреймворки высокого уровня (игровые движки сети поверх Unity и т.п.).
- Внешние системы искусственного интеллекта для ботов.

Причина: эти задачи либо не поставлены в Архитектуре 0.8.6, либо добавят лишний риск для ИИ‑агентов на ранних этапах.

------

## 7. Минимальный глоссарий

**ECS** — подход, при котором данные объекта игры хранятся в компонентах, а логика обновления реализуется отдельными системами.

**Авторитарный сервер** — сервер, который хранит истинное состояние мира и принимает окончательные решения о результатах действий игроков и ботов.

**Протокол с фиксированной схемой** — формат обмена сообщениями, в котором структура данных заранее описана и по этой схеме генерируется код (пример — Protobuf).

**Shared‑библиотека** — отдельный проект с кодом, который одновременно подключается и к клиенту, и к серверу.
