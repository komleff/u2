# U2 — Технологический стек клиента и сервера

Версия: 0.8.6 (минимальная, для ИИ-агентов)

Документ описывает утверждённый набор технологий, достаточный для реализации Архитектуры v0.8.6 (минимальная) и плана разработки v0.8.6.

**Основной клиент:** TypeScript + Canvas/WebGL (браузер)  
**Альтернативный клиент:** Unity (опционально, для будущей 3D-графики)

Цель: дать ИИ-агентам чёткий список библиотек и инструментов с минимальным количеством самописного кода.

------

## 1. Принципы выбора

1. Использовать стандартные библиотеки и инструменты для выбранной платформы, а не писать обвязку с нуля.
2. **Основной клиент:** TypeScript + Canvas/WebGL для максимальной доступности (браузер).
3. **Альтернативный клиент:** Unity (C#) — опционально, для будущей 3D-графики с более сложным рендером.
4. **Сервер:** C# (.NET 8) — для совместимости с возможным Unity-клиентом и общими библиотеками.
5. Общий код для физики, протокола и конфигов в отдельной «shared»‑библиотеке (возможна компиляция в WASM для TypeScript-клиента).
6. Всё, что не требуется Архитектурой 0.8.6 и Планом 0.8.6, в стек не включать.

------

## 2. Сводная таблица технологий

| Область             | Назначение                      | Технология / библиотека                     | Статус                       |
| ------------------- | ------------------------------- | ------------------------------------------- | ---------------------------- |
| **Основной клиент** |                                 |                                             |                              |
| Платформа           | Браузер                         | TypeScript + Vite                           | Обязательно                  |
| Рендер              | 2D/3D графика                   | Canvas 2D / Three.js (WebGL)                | Обязательно                  |
| UI                  | HUD, иконки, текст              | Canvas API / HTML5 элементы                 | Обязательно                  |
| Сетевой транспорт   | Связь с сервером                | WebSocket                                   | Обязательно                  |
| Сериализация        | Сообщения клиент↔сервер         | Protobuf.js                                 | Обязательно                  |
| Физика              | Клиентское предсказание         | TypeScript (или shared WASM)                | Обязательно                  |
| **Альтернативный клиент (Unity)** |                   |                                             |                              |
| Клиентский движок   | Рендер, ввод, сцены             | Unity LTS (3D, URP)                         | Опционально                  |
| Язык на клиенте     | Игровая логика                  | C#                                          | Опционально                  |
| Ввод                | Клавиатура, мышь, геймпад       | Unity Input System                          | Опционально                  |
| UI                  | HUD, иконки, текст              | Unity UI (Canvas + TextMeshPro)             | Опционально                  |
| ECS                 | Сущности/компоненты/системы     | Entitas (или аналогичный зрелый ECS для C#) | Опционально                  |
| **Сервер**          |                                 |                                             |                              |
| Серверная платформа | Авторитарный сервер             | .NET 8 (консольное приложение)              | Обязательно                  |
| Сетевой транспорт   | Надёжный обмен по «UDP‑модели»  | LiteNetLib (ПК/мобайл)                      | Обязательно для ПК/мобайл    |
| Web‑клиенты         | Транспорт для WebGL/браузера    | ASP.NET Core + WebSocket                    | Обязательно для Web          |
| Сериализация        | Сообщения клиент↔сервер         | Google.Protobuf или protobuf‑net            | Обязательно                  |
| Конфиги             | ТТХ кораблей, настройки локаций | JSON + System.Text.Json                     | Обязательно                  |
| Логирование         | Технические логи сервера        | Serilog                                     | Рекомендуется                |
| Метрики             | Время тика, задержки, нагрузки  | prometheus-net                              | Рекомендуется                |
| Тесты               | Модульные/интеграционные тесты  | xUnit или NUnit                             | Обязательно                  |
| Профилирование      | Замеры производительности       | BenchmarkDotNet                             | Рекомендуется                |

**Примечания:**

- Основной фокус разработки — на TypeScript-клиенте для браузера.
- Unity-клиент остаётся опциональным для будущих задач с более сложной 3D-графикой.
- Для Unity-клиента допускается замена Entitas на другой устоявшийся ECS для C# (например, Leopotam.EcsLite).

------

## 3. Основной клиент (TypeScript + Canvas/WebGL)

### 3.1. Платформа и рендер

**Использовать:**

- TypeScript как основной язык.
- Vite для разработки и сборки.
- Canvas 2D для простых 2D-интерфейсов и HUD.
- Three.js (WebGL) для 3D-графики и визуализации космоса.

**Причины:**

- Максимальная доступность: работает в любом современном браузере без установки.
- Three.js предоставляет готовый высокоуровневый API для 3D-рендера.
- Vite обеспечивает быструю разработку с горячей перезагрузкой.

### 3.2. Ввод и интерфейс

**Использовать:**

- Нативные браузерные события (keyboard, mouse, gamepad API) для ввода.
- Canvas API или HTML5-элементы для HUD и отладочных панелей.

**Причины:**

- Стандартные API браузера покрывают все необходимые устройства ввода.
- Не требуется дополнительных библиотек для базового UI.

### 3.3. Физика и состояние на клиенте

**Физика:**

- Для клиентского предсказания используется TypeScript-порт общей физики.
- Опционально: shared-библиотека, скомпилированная в WASM (для полной идентичности с сервером).

**Состояние:**

- Локальное состояние корабля управляется простыми структурами данных (классы/интерфейсы TypeScript).
- Client prediction и reconciliation реализуются в TypeScript.

**Причины:**

- Общая физика должна совпадать с серверной для корректного предсказания.
- TypeScript-порт проще в отладке и интеграции в браузерный клиент.
- WASM-вариант может использоваться для максимальной точности в будущем.

### 3.4. Сетевой протокол

**Использовать:**

- WebSocket для связи с сервером.
- Protobuf.js для сериализации/десериализации сообщений.

**Причины:**

- WebSocket — стандарт для двустороннего обмена в браузере.
- Protobuf.js позволяет использовать те же схемы сообщений, что и на сервере.

------

## 4. Альтернативный клиент (Unity, опционально)

## 4. Альтернативный клиент (Unity, опционально)

> **Примечание:** Unity-клиент является опциональным и предназначен для будущих задач с более сложной 3D-графикой. Основной фокус разработки — на TypeScript-клиенте.

### 4.1. Движок и графика

**Использовать:**

- Unity LTS (одна конкретная LTS‑версия, зафиксировать в репозитории).
- Универсальный рендер‑конвейер (URP) в трёхмерном режиме.

**Причины:**

- Нужен 3D‑рендер для «вида сверху с перспективой» и дальности обзора до 10–20 км.
- URP даёт единый конвейер для ПК и WebGL.

### 4.2. Ввод и интерфейс

**Использовать:**

- `com.unity.inputsystem` для работы с клавиатурой, мышью и геймпадом.
- Стандартный Canvas + TextMeshPro для HUD и отладочных панелей.

**Причины:**

- Позволяет без самописной обвязки поддерживать несколько устройств ввода.
- HUD и отладка реализуются на типовом UI Unity.

### 4.3. Физика и ECS на клиенте

**Физика:**

- Для минимальной версии движение в плоскости рассчитывается в общем C#‑коде (shared‑библиотека), а не через встроенную физику Unity.
- Unity Physics/2D используются только для простых визуальных эффектов (по необходимости), не как основной источник истины.

**ECS:**

- Entitas (или другой зрелый ECS для C#) используется для структурирования клиентской логики: состояние корабля, локальное предсказание, отображение, HUD.

**Причины:**

- Общая физика должна совпадать с серверной, поэтому расчёты выносятся в общий код.
- ECS снижает объём самописной архитектуры: логика строится на готовом паттерне сущность/компонент/система.

------

## 5. Сервер (.NET 8)

### 5.1. Платформа

**Использовать:**

- .NET 8 (консольное приложение без графики).
- C# как основной язык.

**Причины:**

- Совместный стек с Unity‑клиентом (C# и общие библиотеки).
- Современная производительность и поддержка асинхронных операций.

### 5.2. Сетевой транспорт

**ПК/мобайл:**

- LiteNetLib как транспорт поверх протокола датаграмм.
- Режим с надёжными и ненадёжными каналами (для разных типов сообщений).

**WebGL/Браузер:**

- ASP.NET Core Kestrel + встроенная поддержка WebSocket.

**Причины:**

- LiteNetLib закрывает основную часть задач по работе с ненадёжным транспортом (повторы, очереди) без самописного транспорта.
- WebSocket в ASP.NET Core стандартен и хорошо поддерживается.

### 5.3. Сериализация и конфигурации

**Сообщения:**

- Google.Protobuf или protobuf‑net.
- Все игровые пакеты (управление, снимки состояния, события) описываются схемами и генерируются.

**Конфиги:**

- JSON‑файлы с использованием System.Text.Json.
- ТТХ кораблей и параметры локаций — строго описанные структуры, согласованные с документом по ТТХ.

**Причины:**

- Генерация типов по схемам уменьшает объём самописного кода по сериализации.
- System.Text.Json — стандартная библиотека, без внешних зависимостей.

### 5.4. Тесты, логи, метрики

**Тесты:**

- xUnit или NUnit для модульных и интеграционных тестов.

**Логирование:**

- Serilog для структурированных логов (в консоль и, при необходимости, в файл или систему сбора логов).

**Метрики:**

- prometheus-net для экспорта базовых показателей (время тика, число сущностей, задержки).

**Причины:**

- Все перечисленные библиотеки широко применяются и активно поддерживаются, что снижает риски при использовании ИИ‑агентов.

------

## 6. Общая библиотека (Shared)

**Назначение:** код, общий для клиента и сервера.

**Содержимое:**

- Структуры данных для состояния корабля, локации и простого урона.
- Реализация минимальной физики в плоскости (без тепла, щитов и брони).
- Реализация протокола сообщений (типы Protobuf и обёртки).
- Набор систем ECS, общих для клиента и сервера (по мере необходимости).

**Технологии:**

- **Для сервера и Unity-клиента:** C# классическая библиотека.
- **Для TypeScript-клиента:** TypeScript-порт физики или WASM-сборка C#-библиотеки (опционально).
- System.Numerics для векторов (C#), Protobuf-типы для сообщений.

**Причины:**

- Исключение дублирования логики.
- Упрощение работы ИИ‑агентов: вся «истина» по формату данных в одном месте.
- WASM позволяет переиспользовать C#-код в браузере с высокой производительностью.

------

## 7. Что не входит в стек v0.8.6

Сознательно **не включаются** в минимальный стек (но могут появиться в будущих версиях):

- Любые специализированные библиотеки для сложной 3D‑физики, тепла, щитов, брони.
- Сложные сетевые фреймворки высокого уровня (игровые движки сети поверх Unity и т.п.).
- Внешние системы искусственного интеллекта для ботов.

Причина: эти задачи либо не поставлены в Архитектуре 0.8.6, либо добавят лишний риск для ИИ‑агентов на ранних этапах.

------

## 8. Минимальный глоссарий

**ECS** — подход, при котором данные объекта игры хранятся в компонентах, а логика обновления реализуется отдельными системами.

**Авторитарный сервер** — сервер, который хранит истинное состояние мира и принимает окончательные решения о результатах действий игроков и ботов.

**Протокол с фиксированной схемой** — формат обмена сообщениями, в котором структура данных заранее описана и по этой схеме генерируется код (пример — Protobuf).

**Shared‑библиотека** — отдельный проект с кодом, который одновременно подключается и к клиенту, и к серверу.

**WASM (WebAssembly)** — бинарный формат для выполнения кода в браузере с производительностью, близкой к нативной. Позволяет компилировать C#/Rust/C++ код для использования в TypeScript-клиенте.
